\documentclass[a4paper,12pt]{article}

\usepackage[top = 2.5cm, bottom = 2.5cm, left = 2.5cm, right = 2.5cm]{geometry} 

\usepackage[utf8]{inputenc}
\usepackage[czech]{babel}

\usepackage{multirow}
\usepackage{booktabs}

\usepackage{graphicx}
\usepackage{amsfonts}
\usepackage{amsmath}

\usepackage{syntax}

\usepackage{verbatim}
\usepackage[usenames,dvipsnames]{xcolor}
\usepackage{listings}
\usepackage{color}

\lstset{language=C++,
        basicstyle=\ttfamily,
        keywordstyle=\color{blue}\ttfamily,
        morekeywords={constexpr},
        stringstyle=\color{red}\ttfamily,
        commentstyle=\color{gray}\ttfamily
}

\usepackage{setspace}
\setlength{\parindent}{0in}
\setlength{\parskip}{.5em}

\begin{document}
    \section{Gramatika}

    Policy jsou definovány jednoduchou gramatikou definující strukturu dat (rozšiřitelnou o strategie procházení, zarovnání, atd.).

    \begin{grammar}
        <policy> ::= `policy<' <shape> `>'

        <shape> ::= <tag>
        \alt <tag> `, plus, ' <shape>
        \alt <tag> `, cross, ' <shape>
        \alt <tag> `, ' <shape> (same as the previous alternative: i.e. `cross' assumed)

        <tag> ::= <simple_tag>
        \alt <type_tag>

        <simple_tag> ::= <array>
        \alt <tuple>
        \alt <vector>

        <array> ::= `array<' <N> `>'

        <tuple> ::= `tuple<' <shape> `>'

        <vector> ::= `vector'

        <type_tag> ::= <type>
    \end{grammar}

    $\mathbf{\langle simple\_tag \rangle}$ definuje jednoduchou strukturu s běžnou sémantikou.

    $\mathbf{\langle type\_tag \rangle}$ definuje typ dat ve struktuře, funguje na základě definování typového\linebreak``módu'', kdy všechna následující data sdílejí daný typ, podobnou funkci má i $\mathbf{\langle tuple \rangle}$, je-li použit pouze s $\mathbf{\langle type\_tag \rangle}$.

    \textbf{cross} a \textbf{plus} jsou operátory kombinující jednotlivé tagy.
    \textbf{cross} má přednost a jeho význam je, že struktura definovaná levým operandem je složena z podstruktur definovaných pravým operandem. Význam \textbf{plus} je jednoduché řetězení operandů za sebou. Uvnitř $\mathbf{\langle type\_tag \rangle}$ má \textbf{plus} operátor funkci čárky.

    \section{Iterace}

    Jednoduchá iterace je definovaná pro jednoduché policy a pro všechny policy, jež využívají pouze \textbf{cross} operátor. Iterace skrze tuple je prováděna paralelně, zatímco skrze array sekvenčně s intuitivní definicí procházení kombinace tohoto dle definicí výše (jako u matic vždy iterátor řádků, sloupců; iterátory vícerozměrným systémem + s fixovanou danou souřadnicí/souřadnicemi).

    Procházení je definováno pro operátor \textbf{plus} pouze, jsou-li po sobě jdoucí policy kompatibilního typu (vysvětleno příkladem níže), pak je prováděno sekvenčně.

    \subsection{Příklad}

    Uvažujme následující příklad pro ukázání iterace na SoA a AoS:
    \begin{lstlisting}
using policy1 = tuple<float, int, char> cross array<N>; //SoA
using policy2 = array<N> cross tuple<float, int, char>; //AoS

auto i1 = policy1::begin(data);
auto i2 = policy2::begin(data);
    \end{lstlisting}

    potom platí (vedle očekávaných vlastností), že \lstinline{i1->get<n>()} a \lstinline{i2->get<n>()} jsou\linebreak stejného typu (kde $n \in [0..2]$) a je definováno lineární uspořádání na sjednocení množin obou iterátorů (? i operace na nich) tak, že:

    \begin{center}
        \lstinline{policy1::begin(data)} $==$ \lstinline{policy2::begin(data)} $\wedge$
    \lstinline{i1} $==$ \lstinline{i2} $\to$ \lstinline{++i1} $==$ \lstinline{++i2}
    \end{center}

    \section{Funkce \lstinline{at()}}

    Funkce \lstinline{at()} je definována rekurzivním voláním pomocí template například následujícím způsobem (subject to change; zde jen velice zjednodušeně pro array), měla by korespondovat s implementací iterátorů:
    \lstinputlisting{draftsimplified1.cpp}
\end{document}
