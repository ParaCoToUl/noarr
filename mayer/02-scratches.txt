data->at(a)->at(b)->at(c) ... spočítá adresu

operace: +, *, []   závorky jsou skok na adresu, {} je inverz [] - skoč na rodiče

pro array[i]:
    pointer = base_pointer + i * item_size
    --->
    base_pointer = pointer - i * item_size

pro vector[i]:
    pointer = [base_pointer + i * pointer_size]
    --->
    base_pointer = {pointer} - i * pointer_size





pro serializovaná data se všechno chová lineráně:
p = base_p + i_0 * s_0 + i_1 * s_1 + ... + i_n + s_n

krokování je jednoduché:
p ++ i_j = p + s_j




pro dynamická data (tuple nebo vektor prvků různých velikostí - same thing):
MÁME LINEARITU?
Máme, takovou divnou, ale máme (musíme vědět, na kterém prvku jsme abychom věděli
jak velký krok máme udělat na sousední prvek, ale to pro 0 víme!)



pro odkazovaná data:
p = [ ... [[base_p + i_0 * PS] + i_1 * PS] ... + i_n * PS]

krokování je masakr:
p ++ i_j ... MUSÍM VYSKÁKAT NAHORU A PAK ZASE DOLŮ, NENÍ JINÉ CESTY

opravdu musím? Já chci krokovat jen z nuly na K, opravdu by to nešlo???

potřebuju: ... potřebuju zpozdit skok až na později, jde to? Jaké musím mít vlastnosti?
a + f(b) == f(a + b) pro f(x) = x + jmp platí

a + f(b) == f(a + b) == f(a) + b


a + f(b + f(c)) == a + f(b) + f(f(c)) ????




chci, aby příspěvek jedné dimenze o indexu "i" k adrese "p"
byl ve tvaru dopočitatelné konstanty "f(i)" nezávislé na předchozích indexech
... aby se příspěvky daly permutovat

JENŽE TO BOHUŽEL NEJDE
